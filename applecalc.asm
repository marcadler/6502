*===============================
*  CALCULATOR PROGRAM
*===============================

	ORG	$6000

* SYSTEM CALLS

HOME	EQU	$FC58
COUT	EQU	$FDED
OFF80	EQU	$C00C
ON80	EQU	$C00D
KYBD	EQU	$C000
STROBE	EQU	$C010
DELAY	EQU	$FCA8
FRMNUM	EQU	$DD67
PRNTFAC	EQU	$ED2E
VBASE	EQU	$FC24
MONQ	EQU	$FF69

* TABS FOR PRNTFAC

HTAB	EQU	$24
VTAB	EQU	$25

* DISPLAY ADDRESS POINTER AND LENGTH

DISPPTR	EQU	$60
DISPLEN	EQU	$62

* FORMULA ADDRESS POINTER AND LENGTH

FORPTR	EQU	$63
FORLEN	EQU	$65

* MISC

TBLPTR EQU	$66	; LOOKUP TABLE POINTER
CURCHAR	EQU	$68	; CURRENT CHARACTER
OPTYPE	EQU	$69	; OPERATION TYPE
CHAROFF	EQU	$6A	; CHARACTER OFFSET

* TXTPTR FOR USE WITH FRMNUM

TXTPTR	EQU	$B8

*======================
* THE MAGIC STARTS HERE

START	NOP

* CLEAR SCREEN

	JSR	HOME

* PRINT THE DANG THING

	JSR	PRINTCAL

* INITIALIZE COUNTERS ETC

START1	JSR	STARTUP

* THE MAIN LOOP

MAIN	JSR	GETINP

	JSR	BRANCH

	JMP	MAIN

*===================
* STARTUP SUBROUTINE

STARTUP	NOP

* SET DISPLAY POINTER TO $0603

	LDA	#$06
	STA	DISPPTR+1
	LDA	#$03
	STA	DISPPTR

* SET POINTER FOR ENTERED VALUE AND TXTPTR TO $7000

	LDA	#$70
	STA	FORPTR+1
	STA	TXTPTR+1
	LDA	#$00
	STA	FORPTR
	STA	TXTPTR

* CLEAR MEMORY AT $7000

	LDY	#$00
	LDA	#$00
]LOOP	STA	(FORPTR),Y
	INY
	CPY	#$FF
	BNE	]LOOP

* INITIALIZE DISPLEN AND FORLEN

	LDA	#$00
	STA	FORLEN
	STA	DISPLEN

* CLEAR OPTYPE

	LDA	#$00
	STA	OPTYPE

	RTS

*============================
* PRINT CALCULATOR SUBROUTINE

PRINTCAL	NOP

* TURN OFF 80-COL

	STA		OFF80

* TOP HALF

PRINT1	LDX	#$00
]LOOP	LDA	DATA1,X
	BEQ	PRINT2
	JSR	COUT
	INX
	BNE	]LOOP

* BOTTOM HALF

PRINT2	LDX	#$00
]LOOP	LDA	DATA2,X
	BEQ	FINI
	JSR	COUT
	INX
	BNE	]LOOP

FINI	RTS

*=================
* DELAY SUBROUTINE

DEL	NOP
	LDX	#$20
]LOOP	LDA	#$20
	JSR	DELAY
	DEX
	BNE	]LOOP

	RTS

*==============================
* SUBROUTINE FOR FLASHING CHARS

FLASH	NOP

* FIND CURCHAR IN LUT

	LDX	#$00
]LOOP	LDA	DATA3,X
	CMP	CURCHAR
	BEQ	STORE
	INX
	BNE	]LOOP

STORE	INX
	LDA	DATA3,X
	STA	TBLPTR
	INX
	LDA	DATA3,X
	STA	TBLPTR+1

* STORE OFFSET

	LDA	CURCHAR
	CMP	#$C0
	BCC	DIG
	BCS	LET

* OFFSET DIFFERS IF DIGIT OR LETTER

DIG	LDA	#$80
	STA	CHAROFF
	JMP	FLASH1

LET	LDA	#$C0
	STA	CHAROFF

FLASH1	LDA	CURCHAR
	SEC
	SBC	CHAROFF
	LDY	#$00
	STA	(TBLPTR),Y
	JSR	DEL
	LDA	CURCHAR	; ORIGINAL VALUE
	STA	(TBLPTR),Y

	RTS

*========================
* CLEAR DISPLAY SUBROUTINE

CLEAR	NOP

	JSR	FLASH

CLEAR1	LDY	#$00
	LDA	#$A0
]LOOP	STA	(DISPPTR),Y
	INY
	CPY	#$0F
	BNE	]LOOP

* RESET DISPLEN AND FORLEN

	LDA	#$00
	STA	DISPLEN
	STA	FORLEN

* CLEAR MEMORY AT $7000

	LDY	#$00
	LDA	#$00
]LOOP	STA	(FORPTR),Y
	INY
	CPY	#$0F
	BNE	]LOOP

	RTS

*=====================
* GET INPUT SUBROUTINE

GETINP	NOP
	LDA	KYBD
	CMP	#$80	; LESS THAN #$80 = NO INPUT
	BCC	GETINP
	STA	CURCHAR
	STA	STROBE

	RTS

*==================
* BRANCH SUBROUTINE

BRANCH	NOP

* TEST IF OPERATOR, BRANCH ACCORDINGLY

	LDA	CURCHAR

* IF AN OPERATOR (+, -, *, /), SET IT

	CMP	#$AA	; '*'
	BEQ	SETOP
	CMP	#$AB	; '+'
	BEQ	SETOP
	CMP	#$AD	; '-'
	BEQ	SETOP
	CMP	#$AF	; '/'
	BEQ	SETOP

* IF EQUALS, DO THE MATH

	CMP	#$BD	; '='
	BEQ	EQUALST

* IF A DECIMAL POINT, JUST INSERT IT

	CMP	#$AE	; '.'
	BEQ	DEC

* IF C, CLEAR

	CMP	#$C3	; 'C' (CLEAR)
	BEQ	CLEARST

* IF Q THEN QUIT

	CMP	#$D1	; 'Q' (QUIT)
	BEQ	ENDST

* IF NOT ANY OF THE ABOVE, MAYBE A DIGIT

	JMP	DIGCHK

* INSERT DECIMAL POINT

DEC	NOP

	JSR	FLASH

* PRINT IT

	LDA	CURCHAR
	LDY	DISPLEN
	STA	(DISPPTR),Y
	INC	DISPLEN

* STORE IT

	LDA	#$2E
	LDY	FORLEN
	STA	(FORPTR),Y
	INC	FORLEN

	RTS

* SET THE OPERATOR

SETOP	LDA	CURCHAR
	STA	OPTYPE
	JSR	PREP

	RTS

CLEARST	JSR	CLEAR

	RTS

EQUALST	JSR	EQUALS

	RTS

ENDST	JMP	END

* TEST IF LESS THAN ASCII 0 OR GREATER THAN ASCII 9

DIGCHK	CMP	#$B0
	BCC	RETURN
	CMP	#$BA
	BCS	RETURN

	JMP	CONT1

RETURN	RTS

* OKAY, IT'S A DIGIT

* FLASH KEY

CONT1	JSR	FLASH

* TEST IF END OF DISPLAY LINE REACHED

	LDY	DISPLEN
	CPY	#$0F
	BEQ	GETINP2

	JMP	DISP1

GETINP2	RTS

* DISPLAY NUMBER IN CORRECT POSITION IN DISPLAY

DISP1	LDY	DISPLEN
	LDA	CURCHAR
	STA	(DISPPTR),Y
	INC	DISPLEN

* STORE THE APPLESOFT EQUIV TO ASCII VAL TO $7000

	LDY	FORLEN
	LDA	CURCHAR
	SEC
	SBC	#$80	; NUM VAL = ASCII VAL - #$80
	STA	(FORPTR),Y
	INC	FORLEN

	RTS

*========================================
* SUBROUTINE FOR PREP BEFORE AN OPERATION

PREP	NOP

* FLASH THE KEY

	JSR	FLASH

* CONVERT OPERATOR

	LDA	OPTYPE
	CMP	#$AB
	BEQ	ADDOP
	CMP	#$AD
	BEQ	SUBOP
	CMP	#$AA
	BEQ	MULTOP
	CMP	#$AF
	BEQ	DIVOP

ADDOP	LDA	#$C8
	STA	OPTYPE
	JMP	CONT2

SUBOP	NOP

* MIGHT BE NEGATIVE NUMBER

	LDA	DISPLEN
	CMP	#$00
	BNE	SUBOP1

* PRINT AND STORE THE '-'

	LDA	OPTYPE
	LDY	DISPLEN
	STA	(DISPPTR),Y
	INC	DISPLEN

	LDA	#$C9
	STA	OPTYPE
	LDY	FORLEN
	STA	(FORPTR),Y
	INC	FORLEN

	RTS

* IF NOT, THEN IT'S JUST MINUS

SUBOP1	LDA	#$C9
	STA	OPTYPE
	JMP	CONT2

MULTOP	LDA	#$CA
	STA	OPTYPE
	JMP	CONT2

DIVOP	LDA	#$CB
	STA	OPTYPE
	JMP	CONT2

* ADD OPERATOR TO FORMULA

CONT2	LDY	FORLEN
	LDA	OPTYPE
	STA	(FORPTR),Y
	INC	FORLEN

* CLEAR DISPLAY

	LDY	#$00
	LDA	#$A0
]LOOP	STA	(DISPPTR),Y
	INY
	CPY	#$0F
	BNE	]LOOP

* RESET DISPLEN

	LDA	#$00
	STA	DISPLEN

	RTS

*=========
* THE MATH

EQUALS	NOP

* DON'T DO ANYTHING IF NO FORMULA

	LDA	$7000
	CMP	#$00
	BEQ	BYE

	JMP	CONT3

BYE	RTS

* FLASH THE KEY

CONT3	JSR	FLASH

* CLEAR DISPLAY

	LDY	#$00
	LDA	#$A0
]LOOP	STA	(DISPPTR),Y
	INY
	CPY	#$0F
	BNE	]LOOP

* RESET DISPLEN

	LDA	#$00
	STA	DISPLEN

* ADD #$00 AFTER FORMULA

	LDA	#$00
	INC	FORLEN
	LDY	FORLEN
	STA	(FORPTR),Y

* DO THE CALCULATION

	JSR	FRMNUM

* PRINT THE RESULT

	LDA	#$03
	STA	HTAB
	LDA	#$04
	STA	VTAB
	JSR	VBASE

	JSR	PRNTFAC

	JMP	START1

END	RTS

DATA1 ASC " _________________"8D
	ASC " |                 |"8D
	ASC " |   APPLECALC-1   |"8D
	ASC " |-----------------|"8D
	ASC " |                 |"8D
	ASC " |=================|"8D
	ASC " |                 |"8D
	ASC " |  C              |"8D
	ASC " |                 |"8D
	HEX 00

DATA2 ASC " |  7   8   9   /  |"8D
	ASC " |                 |"8D
	ASC " |  4   5   6   *  |"8D
	ASC " |                 |"8D
	ASC " |  1   2   3   -  |"8D
	ASC " |                 |"8D
	ASC " |  0   .   =   +  |"8D
	ASC " |                 |"8D
	ASC " |_________________|"8D
	HEX	00

* LOOKUP TABLE FOR NUMPAD KEY ADDRESSES

DATA3	HEX	B0AC07	; 0 $07AC
	HEX	B1AC06 ; 1 $06AC
	HEX	B2B006 ; 2 $06B0
	HEX	B4AC05 ; 4 $05AC
	HEX	B3B406 ; 3 $06B4
	HEX	B5B005 ; 5 $05B0
	HEX	B6B405 ; 6 $05B4
	HEX	B7AC04 ; 7 $04AC
	HEX	B8B004 ; 8 $04B0
	HEX	B9B404 ; 9 $04B4
	HEX	C38407 ; C $0784
	HEX	AFB804 ; / $04B8
	HEX	AAB805 ; * $05B8
	HEX	ADB806 ; - $06B8
	HEX	ABB807 ; + $07B8
	HEX	BDB407 ; = $07B4
	HEX	AEB007 ; . $07B0
